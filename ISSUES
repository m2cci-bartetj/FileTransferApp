
1. Error handling : MOSTLY (BADLY) DONE. At the moment, only errors on file handling + allocation of memory.
The exchange is kept even if error. Not optimal at all. We just check at the end of the exchange if exchanged 
data was relevant or not. We need to add error checks at the start of each sent/received messages. 
These would correspond to errno code. So each message would have 'errno + data'. At the reception,
if received errno != 0, close connexion. Else, continue. On the side of the machine which sent 'errno + data', 
if errno != 0, close connection. So we would need an additional function to read errno and close connexion if required.
This would be more optimal than the present choice, although that would mean we have several ways of exiting the code.

2. File handling : at the moment, we store the full file in a single go. NOT GOOD. If the file is heavy,
 then that would mean having a file_content variable quite sizable, and enough to eat too much memory. Same
 would happen on the server's side. Solution : send the file content by pieces (preferably of multiples of 1448
 bytes to avoid un-necessary padding), and read and store by pieces. This requires :
        - a ReadFile() function with input parameter the size of the block to read + position of lecture.
        - a seperate SizeFile() function to get the size of the file seperatly from the reading
        - a WriteFile() function with input parameter the size of the block to write, and the writing options
            ( "wb" only at the start to squash any existing file, then "ab" to add content at the end.)
OR since getting the position is heavy, inside the ReadFile function, open the file once, do a loop, and
inside read x bytes and send x bytes. Until sum_nb_bytes_written = size of file OR until end of file mark.
>> At the moment, we at least seperated the search of the file contents and file size, and only allocated memory
in the main codes client/server.c. It makes things cleaner + one less fseek.

3. No endianess handling. We suppose client and server share the same convention

4. No sizeof(int) checks. We suppose int is always of size 4. Might apparently not always be the case.

5. No checks if the file to be transfered already exists in destination. There is no warning if the file
exists, it is systematically crushed.

6. The document in the server can only be stored where the exe server is executed. We should ask for a destination path
and check if it exists with the server. If exits => continue. If not, server's side : send error code & next
information to read : choice. Client's side : send path, read recieved error. If ok, continue. If nok, break.
Same when we want to get file : we can only store it where client is called.

9. Display more than first existing files in current repertory. Which means that the client must search a different way
the existences of the file name it wants to retrieve.

7. Use allocated memory for file system. And better printing !

8. Replace scanf by fgets to control size of input string.

10. Sending is done property by property for testing reasons. However, this is a loss of time since un-used padding must be 
added to eah sent package. The heavier the property %1448, the better.

11. Sequential server : it can treat only one client at a time. Multiple clients would be interesting => use fork().
>> DONE

12. Problem with word search in string : any substring of main string works. We must format file system to have space at the
start and end of each file name. And add spaces on both sides of the file name given by the operator. Then check using same
function.
